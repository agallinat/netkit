[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Alex Gallinat Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"0. Installation","title":"Introduction to netkit","text":"netkit can installed github, follows:","code":"# If not already installed: install.packages(\"devtools\")  # Install netkit from GitHub devtools::install_github(\"agallinat/netkit\") # Load netkit library(netkit)"},{"path":"/articles/introduction.html","id":"annotate-graphs","dir":"Articles","previous_headings":"","what":"1. Annotate Graphs","title":"Introduction to netkit","text":"tutorial use two different synthetic graphs generated using igraph::sample_pa() igraph::sample_gnp() functions. also generate two data.frame objects containing simulated nodes’ edges’ metadata included original graph. instance, simulated metadata represent gene expression results, entity types, edge confidence scores, effect interaction, type information, may useful include igraph object. can annotate existing graph, using assign_attributes() function. matching nodes edges updated. Warnings issued unmatched entries.","code":"suppressMessages(library(igraph))  set.seed(123)  # Generate synthetic graphs g <- sample_pa(100, power = 1.5, directed = F) V(g)$name <- as.character(1:vcount(g))  g2 <- sample_gnp(100, 0.02, directed = T) V(g2)$name <- as.character(1:vcount(g2))  # Simulate nodes and edges metadata nodes_info <- data.frame(node = V(g)$name,                           category = sample(LETTERS, vcount(g), replace = T),                          score = rnorm(vcount(g)))  edges <- as_edgelist(g) edges_info <- data.frame(from = edges[,1], to = edges[,2], edge_score = rnorm(ecount(g))) library(netkit)  # Add metadata to an existing graph g <- assign_attributes(g, nodes_table = nodes_info, edge_table = edges_info)  vertex_attr_names(g) #> [1] \"name\"     \"category\" \"score\" edge_attr_names(g) #> [1] \"edge_score\""},{"path":"/articles/introduction.html","id":"network-visualization","dir":"Articles","previous_headings":"","what":"2. Network Visualization","title":"Introduction to netkit","text":"plot_Net() main visualization function. supports size/color mapping nodes edges using existing nodes’ metadata. also allows layout control.      Specific nodes can also highlighted using function highlight_nodes() nodes’ name. Highlighting method (label, fill /outline) colors can customized . Aditional arguments passed plot_Net() function:  functions (plot_Net() highlight_nodes()) also allow layout control via layout parameter. accepts coordinates matrix custom generated layout functions available igraph package. special layout option implemented netkit package display network horizontal tree (layout_horizontal_tree()). particularly useful show hierarchical relationships.","code":"# In the default plot, nodes' size is mapped to degree and edges' width to betweenness plot_Net(g) # Nodes size and edge with scalling factors can be modified at will.  plot_Net(g, edge.width.factor = 0.3, node.size.factor = 2) # And turned off plot_Net(g, node.degree.map = F, edge.bw.map = F) # Node colors can be mapped to existing nodes metadata plot_Net(g, color = \"score\", node.degree.map = F) # For directed graphs, arrow sizes are also easily custimizable plot_Net(g2, edge.width.factor = 0.5, node.size.factor = 2, edge.arrow.size = 0.3) highlight_nodes(g, nodes = c(\"1\", \"2\", \"4\"), method = c(\"outline\", \"fill\"),                 edge.width.factor = 0.3, node.degree.map = FALSE) plot_Net(g, edge.width.factor = 0.3, node.size.factor = 2,          layout = layout_horizontal_tree(g))"},{"path":[]},{"path":"/articles/introduction.html","id":"global-topology","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.1. Global topology","title":"Introduction to netkit","text":"core functions global network topology analysis plot_CCDF(), generates plot complementary cumulative degree distribution (CCDF), sumarize_graph_metrics(), calculates following parmeters input graph: Number nodes edges Directed TRUE/FALSE Graph density Diameter average path length largest connected component Clustering coefficient (transitivity) Degree assortativity Average degree betweenness centrality Number connected components size largest connected component Number single nodes Algebraic connectivity (second-smallest Laplacian eigenvalue) Degree entropy (Shannon entropy degree distribution) Gini coefficient node degrees Modularity community structure (via Louvain algorithm) function compare_networks(), accepts two graphs input, computes metrics , associated (CCDF).","code":"# Global topology analysis summarize_graph_metrics(g) #>   Nodes Edges Is_directed Density Diameter Average_path_length #> 1   100    99       FALSE    0.02       10            5.027273 #>   Clustering_coefficient Degree_assortativity Avg_degree Avg_betweenness #> 1                      0           -0.4943885       1.98          199.35 #>   Components Single_nodes LCC_size LCC_percent Algebraic_connectivity #> 1          1            0      100           1             0.01500655 #>   Degree_entropy Gini_degree Modularity #> 1       1.504678   0.4341414  0.7809917  # Complementary cumulative degree distribution # It optionally shows a power law reference distribution of chosen gamma. plot_CCDF(g, show_PL = TRUE, PL_exponents = c(1.5)) # Same analyses to compare two networks compare_networks(g, g2) #> $CCDF_plot #>  #> $global_topology #>   Nodes Edges Is_directed   Density Diameter Average_path_length #> 1   100    99       FALSE 0.0200000       10            5.027273 #> 2   100   183        TRUE 0.0369697        8            3.583333 #>   Clustering_coefficient Degree_assortativity Avg_degree Avg_betweenness #> 1             0.00000000           -0.4943885       1.98          199.35 #> 2             0.03725598            0.1039542       3.66          117.80 #>   Components Single_nodes LCC_size LCC_percent Algebraic_connectivity #> 1          1            0      100        1.00           1.500655e-02 #> 2          4            2       96        0.96           3.560702e-18 #>   Degree_entropy Gini_degree Modularity #> 1       1.504678   0.4341414  0.7809917 #> 2       2.824170   0.2796721  0.4884589 #>  #> $similarity #>   jaccard_similarity node_overlap edge_overlap #> 1        0.003558719            1  0.003558719 #>  #> $ks_test #>  #>  Asymptotic two-sample Kolmogorov-Smirnov test #>  #> data:  deg1 and deg2 #> D = 0.62, p-value < 2.2e-16 #> alternative hypothesis: two-sided"},{"path":"/articles/introduction.html","id":"robustness-analyisis","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.2. Robustness Analyisis","title":"Introduction to netkit","text":"package implements robustness_analysis() simulating network robustness targeted random node removal, following framework Albert et al., 2000. context, robustness refers network’s ability maintain connectivity functionality nodes removed — either randomly (failures) targeted manner (attacks). distinction particularly relevant biological networks, random failures may represent stochastic damage (e.g., mutations, degradation), targeted attacks can simulate inhibition key regulatory nodes drug targets. function accepts parameter removal_strategy defines order nodes removed. can one : \"random\", \"degree\", \"betweenness\", name numeric vertex attribute. Custom attributes interpreted priority scores (higher = removed first). step, function tracks size largest connected component, allowing visualization rapidly network fragments scenario. analysis useful evaluate network resilience identify critical nodes whose disruption may disproportionately affect system integrity. removal strategy set \"random\" n_reps > 1, summarized data frame (mean SD) returned summary.","code":"# Robustness analysis robustness_analysis(g, removal_strategy = \"betweenness\") #> $plot #>  #> $all_results #> # A tibble: 50 × 6 #>      rep removed removed_frac lcc_size efficiency n_components #>    <int>   <int>        <dbl>    <dbl>      <dbl>        <dbl> #>  1     1       1       0.0101       54    0.107             17 #>  2     1       2       0.0202       20    0.0587            23 #>  3     1       4       0.0404       18    0.0411            37 #>  4     1       6       0.0606        8    0.0140            58 #>  5     1       8       0.0808        7    0.0130            58 #>  6     1      10       0.101         6    0.0103            62 #>  7     1      12       0.121         4    0.00705           67 #>  8     1      14       0.141         4    0.00492           71 #>  9     1      16       0.162         3    0.00387           72 #> 10     1      18       0.182         3    0.00256           74 #> # ℹ 40 more rows #>  #> $summary #> # A tibble: 50 × 6 #>      rep removed removed_frac lcc_size efficiency n_components #>    <int>   <int>        <dbl>    <dbl>      <dbl>        <dbl> #>  1     1       1       0.0101       54    0.107             17 #>  2     1       2       0.0202       20    0.0587            23 #>  3     1       4       0.0404       18    0.0411            37 #>  4     1       6       0.0606        8    0.0140            58 #>  5     1       8       0.0808        7    0.0130            58 #>  6     1      10       0.101         6    0.0103            62 #>  7     1      12       0.121         4    0.00705           67 #>  8     1      14       0.141         4    0.00492           71 #>  9     1      16       0.162         3    0.00387           72 #> 10     1      18       0.182         3    0.00256           74 #> # ℹ 40 more rows #>  #> $auc #> $auc$lcc_size #> [1] 0.04638982 #>  #> $auc$efficiency #> [1] 0.03235174 #>  #> $auc$n_components #> [1] 0.5862681"},{"path":"/articles/introduction.html","id":"hubs","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.3. Hubs","title":"Introduction to netkit","text":"Hub nodes defined nodes particularly high degree betweenness centrality. Using function find_hubs(), can identify nodes using either z-score quantile thresholds degree betweenness centrality. function generates diagnostic plot visualize classification using scatter plot marginal histograms.  diagnostic plot generated using ggplot2 ggExtra layer. Additional ggplot2 parameters layers added plot rendered. reason, function includes argument gg_extra = list() passes comma-separated ggplot2 parameters layers plot rendering, follows:","code":"# Hubs detection find_hubs(g, method = \"zscore\",            degree_threshold = 2.5,            betweenness_threshold = 1,           hub_names = TRUE) # to display hub nodes' label in the diagnostic plot #> $plot #>  #> $method #> [1] \"Hub nodes identified by method: zscore with Degree metric threshold = 2.5 and Betweenness metric threshold = 1\" #>  #> $result #> # A tibble: 100 × 6 #>    node  degree betweenness degree_metric betweenness_metric is_hub #>    <chr>  <dbl>       <dbl>         <dbl>              <dbl> <lgl>  #>  1 1          7      0.662          2.42               4.84  FALSE  #>  2 2          3      0.543          0.977              4.08  FALSE  #>  3 3          2      0.287          0.377              2.23  FALSE  #>  4 4         14      0.298          3.73               2.31  TRUE   #>  5 5         17      0.669          4.11               4.88  TRUE   #>  6 6          4      0.0794         1.44               0.424 FALSE  #>  7 7          1      0             -0.469             -0.358 FALSE  #>  8 8         16      0.348          4.00               2.70  TRUE   #>  9 9          2      0.0202         0.377             -0.153 FALSE  #> 10 10         2      0.0202         0.377             -0.153 FALSE  #> # ℹ 90 more rows #>  #> $graph #> IGRAPH fa9e426 UN-- 100 99 -- Barabasi graph #> + attr: name (g/c), power (g/n), m (g/n), zero.appeal (g/n), algorithm #> | (g/c), name (v/c), category (v/c), score (v/n), is_hub (v/l), #> | edge_score (e/n) #> + edges from fa9e426 (vertex names): #>  [1] 1 --2  1 --3  3 --4  2 --5  5 --6  6 --7  1 --8  4 --9  8 --10 5 --11 #> [11] 5 --12 12--13 5 --14 8 --15 6 --16 2 --17 14--18 4 --19 1 --20 5 --21 #> [21] 20--22 19--23 12--24 12--25 25--26 12--27 14--28 12--29 12--30 5 --31 #> [31] 4 --32 30--33 28--34 17--35 23--36 1 --37 12--38 22--39 5 --40 6 --41 #> [41] 5 --42 4 --43 8 --44 8 --45 8 --46 4 --47 4 --48 5 --49 10--50 5 --51 #> [51] 35--52 1 --53 8 --54 30--55 4 --56 12--57 5 --58 4 --59 28--60 46--61 #> + ... omitted several edges # First we need to load `ggplot2` library for suppressMessages(library(ggplot2))  # Hubs detection plot customization. # Notice all arguments in `gg_extra` are in list format, separated with commas, not `+` signs (as usual for `ggplot2`) # To modify the color of the highlighted area in the plot, use the argument `focus_color`. hubs_result <- find_hubs(g, method = \"zscore\", degree_threshold = 2.5, betweenness_threshold = 1,                          focus_color = \"purple\",                           gg_extra = list(xlim(c(-2, 6)),                                          ylim(c(-2, 6)),                                          ggtitle(\"Hubs detection\"),                                          theme_minimal(),                                          theme(legend.position = \"bottom\")))  hubs_result$plot"},{"path":"/articles/introduction.html","id":"bottlenecks","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.4. Bottlenecks","title":"Introduction to netkit","text":"Bottlenecks defined nodes particularly high betweenness centrality low degree. Similarly find_hubs() function, can use find_bottlenecks() identify nodes. Either z-score quantile thresholds can employed degree betweenness centrality thresholding. function generates diagnostic plot visualize classification using scatter plot marginal histograms. find_hubs(), function includes argument gg_extra = list() passes comma-separated ggplot2 parameters layers plot rendering, allow full plot customization.","code":"# Bottlenecks detection find_bottlenecks(g,                   method = \"zscore\") #> $plot #>  #> $method #> [1] \"Bottlenecks identified by method: zscore with Degree metric threshold = -1 and Betweenness metric threshold = 1\" #>  #> $result #> # A tibble: 100 × 6 #>    node  degree betweenness degree_metric betweenness_metric is_bottleneck #>    <chr>  <dbl>       <dbl>         <dbl>              <dbl> <lgl>         #>  1 1          7      0.662          2.42               4.84  FALSE         #>  2 2          3      0.543          0.977              4.08  FALSE         #>  3 3          2      0.287          0.377              2.23  FALSE         #>  4 4         14      0.298          3.73               2.31  FALSE         #>  5 5         17      0.669          4.11               4.88  FALSE         #>  6 6          4      0.0794         1.44               0.424 FALSE         #>  7 7          1      0             -0.469             -0.358 FALSE         #>  8 8         16      0.348          4.00               2.70  FALSE         #>  9 9          2      0.0202         0.377             -0.153 FALSE         #> 10 10         2      0.0202         0.377             -0.153 FALSE         #> # ℹ 90 more rows #>  #> $graph #> IGRAPH fa9e426 UN-- 100 99 -- Barabasi graph #> + attr: name (g/c), power (g/n), m (g/n), zero.appeal (g/n), algorithm #> | (g/c), name (v/c), category (v/c), score (v/n), is_bottleneck (v/l), #> | edge_score (e/n) #> + edges from fa9e426 (vertex names): #>  [1] 1 --2  1 --3  3 --4  2 --5  5 --6  6 --7  1 --8  4 --9  8 --10 5 --11 #> [11] 5 --12 12--13 5 --14 8 --15 6 --16 2 --17 14--18 4 --19 1 --20 5 --21 #> [21] 20--22 19--23 12--24 12--25 25--26 12--27 14--28 12--29 12--30 5 --31 #> [31] 4 --32 30--33 28--34 17--35 23--36 1 --37 12--38 22--39 5 --40 6 --41 #> [41] 5 --42 4 --43 8 --44 8 --45 8 --46 4 --47 4 --48 5 --49 10--50 5 --51 #> [51] 35--52 1 --53 8 --54 30--55 4 --56 12--57 5 --58 4 --59 28--60 46--61 #> + ... omitted several edges"},{"path":"/articles/introduction.html","id":"calculate-roles","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.5. Calculate Roles","title":"Introduction to netkit","text":"Beyond classical hubs bottlenecks, package implements function calculate_roles() node role classification based within-module -module connectivity, described Guimerà & Amaral, 2005, defines nodes’ roles using two metrics: Within-module degree z-score: measures well-connected node others within module (.e., local hubness). Participation coefficient: quantifies evenly node’s links distributed across different modules, capturing inter-modular connectivity. Combining dimensions allows classification nodes distinct structural roles — module hubs, connectors, peripheral nodes — providing insight individual elements contribute local global network organization. function generates classic ggplot2 object, thus, resulting plot fully customizable ggplot2.","code":"# Hubs detection calculate_roles(g,                 label.size = 15,                 label_region = c(\"R3\", \"R6\")) # to display the label of nodes with roles 'R1' and 'R2' in the plot. #> $plot #>  #> $roles_definitions #>   Name                Description                       Condition #> 1   R1 Ultra-peripheral (non-hub)             z < 2.5 & P <= 0.05 #> 2   R2       Peripheral (non-hub)   z < 2.5 & 0.05 < P & P <= 0.6 #> 3   R3          Non-hub connector    z < 2.5 & 0.6 < P & P <= 0.8 #> 4   R4            Non-hub kinless               z < 2.5 & P > 0.8 #> 5   R5             Provincial hub            z >= 2.5 & P <= 0.25 #> 6   R6              Connector hub z >= 2.5 & 0.25 < P & P <= 0.75 #> 7   R7                Kinless hub             z >= 2.5 & P > 0.75 #>  #> $result #> # A tibble: 100 × 6 #>    node  module       z     p role  stringsAsFactors #>    <chr>  <int>   <dbl> <dbl> <chr> <lgl>            #>  1 1          3  2.43   0.449 R2    FALSE            #>  2 2          3  0.152  0.444 R2    FALSE            #>  3 3          3 -0.608  0.5   R2    FALSE            #>  4 4          2  3.85   0.133 R5    FALSE            #>  5 5          9  3.33   0.484 R6    FALSE            #>  6 6          8  1.57   0.375 R2    FALSE            #>  7 7          8 -0.671  0     R1    FALSE            #>  8 8          6  3.86   0.227 R5    FALSE            #>  9 9          2  0.0407 0     R1    FALSE            #> 10 10         6  0.0375 0     R1    FALSE            #> # ℹ 90 more rows"},{"path":"/articles/introduction.html","id":"modules","dir":"Articles","previous_headings":"2. Network Visualization","what":"3.6. Modules","title":"Introduction to netkit","text":"package also implements function identify modules (communities) network using variety community detection algorithms igraph package (e.g., Louvain, Walktrap, Infomap). Optionally filters small modules, visualizes detected modules, returns induced subgraphs module. Additional parameters passed plot_Net() function, allowing full customization network plot.","code":"# Find modules find_modules(g,               method = \"louvain\",              edge.width.factor = 0.3, node.size.factor = 2) #> $module_table #> # A tibble: 100 × 2 #>    node  module #>    <chr>  <int> #>  1 1          1 #>  2 2          1 #>  3 3          1 #>  4 4          2 #>  5 5          3 #>  6 6          4 #>  7 7          4 #>  8 8          5 #>  9 9          2 #> 10 10         5 #> # ℹ 90 more rows #>  #> $n_modules #> [1] 8 #>  #> $subgraphs #> NULL #>  #> $method #> [1] \"louvain\" #>  #> $graph #> IGRAPH fa9e426 UN-- 100 99 -- Barabasi graph #> + attr: name (g/c), power (g/n), m (g/n), zero.appeal (g/n), algorithm #> | (g/c), name (v/c), category (v/c), score (v/n), module (v/n), color #> | (v/c), label (v/c), edge_score (e/n) #> + edges from fa9e426 (vertex names): #>  [1] 1 --2  1 --3  3 --4  2 --5  5 --6  6 --7  1 --8  4 --9  8 --10 5 --11 #> [11] 5 --12 12--13 5 --14 8 --15 6 --16 2 --17 14--18 4 --19 1 --20 5 --21 #> [21] 20--22 19--23 12--24 12--25 25--26 12--27 14--28 12--29 12--30 5 --31 #> [31] 4 --32 30--33 28--34 17--35 23--36 1 --37 12--38 22--39 5 --40 6 --41 #> [41] 5 --42 4 --43 8 --44 8 --45 8 --46 4 --47 4 --48 5 --49 10--50 5 --51 #> [51] 35--52 1 --53 8 --54 30--55 4 --56 12--57 5 --58 4 --59 28--60 46--61 #> + ... omitted several edges"},{"path":"/articles/introduction.html","id":"information-flow","dir":"Articles","previous_headings":"","what":"4. Information flow","title":"Introduction to netkit","text":"Understanding signals propagate across network key step many systems-level analyses. Information flow analysis allows users identify nodes likely influenced stimulus , conversely, nodes can best influence desired set targets. instance, biological networks, information flow analysis key pathway reconstruction, associate nodes (genes/proteins) molecular functions diseases, prioritize candidate drugs given target.","code":""},{"path":"/articles/introduction.html","id":"network-diffusion","dir":"Articles","previous_headings":"4. Information flow","what":"4.1. Network Diffusion","title":"Introduction to netkit","text":"functions network_diffusion() network_diffusion_with_pvalues() simulate spread information set seed nodes across network. functions supports several diffusion models (\"laplacian\", \"heat\", \"rwr\") computes propagated signal every node network. network_diffusion_with_pvalues() extension network_diffusion() assesses statistical significance diffusion scores comparing null distribution obtained via permutation testing (random seed sets size). tools useful identifying nodes impacted set sources, disease genes, drug targets, signaling proteins.","code":"# Diffusion analysis # Select random genes as seed nodes seed_nodes <- sample(vertex_attr(g, \"name\"), 5)  network_diffusion(g, seed_nodes = seed_nodes, method = \"laplacian\") #> # A tibble: 100 × 2 #>    node  score #>    <chr> <dbl> #>  1 44    0.858 #>  2 64    0.851 #>  3 17    0.678 #>  4 23    0.627 #>  5 30    0.531 #>  6 36    0.208 #>  7 19    0.153 #>  8 33    0.138 #>  9 55    0.138 #> 10 75    0.138 #> # ℹ 90 more rows  network_diffusion_with_pvalues(g, seed_nodes = seed_nodes, method = \"laplacian\") #> Running 1000 permutations with 5 random seed nodes each (parallelized)... #> # A tibble: 100 × 4 #>    node  score p_empirical stringsAsFactors #>    <chr> <dbl>       <dbl> <lgl>            #>  1 44    0.858    0.000999 FALSE            #>  2 64    0.851    0.000999 FALSE            #>  3 17    0.678    0.000999 FALSE            #>  4 23    0.627    0.000999 FALSE            #>  5 30    0.531    0.000999 FALSE            #>  6 36    0.208    0.000999 FALSE            #>  7 19    0.153    0.000999 FALSE            #>  8 33    0.138    0.000999 FALSE            #>  9 55    0.138    0.000999 FALSE            #> 10 75    0.138    0.000999 FALSE            #> # ℹ 90 more rows"},{"path":"/articles/introduction.html","id":"reverse-network-diffusion","dir":"Articles","previous_headings":"4. Information flow","what":"4.2. Reverse Network Diffusion","title":"Introduction to netkit","text":"function greedy_seed_selection() implements greedy algorithm select set seed nodes (size k) maximize total diffusion signal given set target nodes. reverse diffusion approach can thought solving inverse problem: Given set nodes want affect, upstream nodes (seeds) perturb maximally reach ? method especially relevant contexts like: Designing combinatorial interventions target disease module. Optimizing signal propagation modulate known gene signature. Identifying minimal upstream regulators observed phenotypes. function also includes optional argument candidate_nodes, character vector eligible nodes’ names considered seeds. NULL (default), non-target nodes used. simulating optimizing diffusion iteratively, greedy_seed_selection() helps prioritize actionable nodes large complex networks. Note: Reverse diffusion computationally hard problem, testing possible combinations seed nodes combinatorially explosive -even small networks-. function solves problem greedy algorithm, node increases total diffusion signal target nodes added iteration (one time). heuristic approach guarantee absolute best seed set, performs well real-world networks lapses reasonable time, making ideal exploratory applied analyses.  generated plot also ggplot2 object, thus, fully customizable.","code":"# Select random genes as target nodes target_nodes <- sample(vertex_attr(g, \"name\"), 5)  greedy_seed_selection(g, target_nodes = target_nodes, k = 20, method = \"laplacian\") #> $selected_seeds #>  [1] \"86\" \"61\" \"99\" \"5\"  \"6\"  \"12\" \"7\"  \"16\" \"8\"  \"11\" \"31\" \"40\" \"42\" \"49\" \"51\" #> [16] \"58\" \"78\" \"83\" \"98\" \"24\" #>  #> $final_target_score #> [1] 1.038675 #>  #> $scores_at_each_step #>  [1] 0.2144644 0.3864561 0.5584479 0.6541527 0.7451539 0.8200176 0.8436105 #>  [8] 0.8672034 0.8862057 0.9000958 0.9139859 0.9278760 0.9417661 0.9556562 #> [15] 0.9695462 0.9834363 0.9973264 1.0112165 1.0251066 1.0386749 #>  #> $plot"},{"path":"/articles/introduction.html","id":"credits-and-contributions","dir":"Articles","previous_headings":"","what":"5. Credits and Contributions","title":"Introduction to netkit","text":"netkit developed, mantained, Alex Gallinat, PhD. Contributions welcome! ’d like report bug, suggest feature, improve documentation, please open issue submit pull request : https://github.com/agallinat/netkit/issues larger changes, feel free open discussion first.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alex Gallinat. Maintainer. PhD. .","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gallinat DA (2025). netkit: Network Analysis Toolkit Biological Graphs. R package version 0.0.1, https://agallinat.github.io/netkit.","code":"@Manual{,   title = {netkit: Network Analysis Toolkit for Biological Graphs},   author = {Dr. Alex Gallinat},   year = {2025},   note = {R package version 0.0.1},   url = {https://agallinat.github.io/netkit}, }"},{"path":"/index.html","id":"netkit","dir":"","previous_headings":"","what":"Network Analysis Toolkit for Biological Graphs","title":"Network Analysis Toolkit for Biological Graphs","text":"goal netkit provide comprehensive user-friendly toolkit network-based data analysis, particularly biological systems analysis. includes tools flexible graph annotation, topological analysis, network visualization, diffusion-based signal propagation. Advanced features include greedy algorithm reverse diffusion analysis — predicting optimal seed node sets maximize signal propagation specified set target nodes — tools simulating network robustness targeted random node removal, following framework Albert et al., 2000. Additionally, netkit implements node role classification based within-module -module connectivity, described Guimerà & Amaral, 2005. special scope generate high-quality interpretable figures suitable publication, functions generate tabular results diagnostic plots. package also offers flexible network visualization options support node/edge metadata mapping, dynamic sizing, layout control. Altogether, netkit designed help researchers explore, interpret, visualize complex networks minimal friction maximum insight.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Network Analysis Toolkit for Biological Graphs","text":"can install development version netkit GitHub using devtools remotes package:","code":"# If not already installed: install.packages(\"devtools\")  # Install netkit from GitHub devtools::install_github(\"agallinat/netkit\")"},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Network Analysis Toolkit for Biological Graphs","text":"Full usage examples tutorial available package vignettes: online: Introduction netkit","code":"browseVignettes(\"netkit\")"},{"path":"/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Network Analysis Toolkit for Biological Graphs","text":"Contributions welcome! ’d like report bug, suggest feature, improve documentation, please open issue submit pull request : https://github.com/agallinat/netkit/issues larger changes, feel free open discussion first.","code":""},{"path":"/reference/assign_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign Vertex and Edge Attributes to an igraph Graph — assign_attributes","title":"Assign Vertex and Edge Attributes to an igraph Graph — assign_attributes","text":"Adds updates vertex edge attributes igraph object using user-provided metadata tables. Vertex attributes matched first column nodes_table, edge attributes matched using first two columns edge_table, taking graph direction account. matching nodes edges updated. Warnings issued unmatched entries.","code":""},{"path":"/reference/assign_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign Vertex and Edge Attributes to an igraph Graph — assign_attributes","text":"","code":"assign_attributes(   graph,   nodes_table = NULL,   edge_table = NULL,   overwrite = TRUE )"},{"path":"/reference/assign_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign Vertex and Edge Attributes to an igraph Graph — assign_attributes","text":"graph igraph object data frame containing symbolic edge list. nodes_table Optional. data.frame whose first column corresponds vertex names. edge_table Optional. data.frame whose first two columns correspond source target vertices. overwrite Logical. TRUE, existing attributes overwritten. FALSE, existing attributes preserved. Default TRUE.","code":""},{"path":"/reference/assign_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign Vertex and Edge Attributes to an igraph Graph — assign_attributes","text":"igraph object added updated attributes.","code":""},{"path":"/reference/calculate_roles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"Implements node role classification system Guimerà & Amaral (2005) calculating within-module degree z-score participation coefficient node network. Nodes assigned one seven role categories (R1–R7) based local modular connectivity.","code":""},{"path":"/reference/calculate_roles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"","code":"calculate_roles(   graph,   communities = NULL,   cluster.method = \"spinglass\",   plot = TRUE,   highlight_roles = TRUE,   hub_z = 2.5,   label_region = NULL,   label.size = 12 )"},{"path":"/reference/calculate_roles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"graph igraph object representing network. communities Optional. community clustering object (returned igraph clustering function), named membership vector. NULL, community detection performed using cluster.method. cluster.method Character. Clustering algorithm use communities NULL. Default \"spinglass\". Passed find_modules(). plot Logical. Whether generate 2D plot participation coefficient (P) vs. within-module z-score (z). Default TRUE. highlight_roles Logical. TRUE, role regions z–P plane shaded visual clarity. Default TRUE. hub_z Numeric. Threshold defining hubs terms within-module z-score. Default 2.5. label_region Optional character vector role labels (e.g., c(\"R4\", \"R7\")) indicating role regions nodes labeled plot. Default NULL. label.size Numeric. Base font size plot text. Default 12.","code":""},{"path":"/reference/calculate_roles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"list three elements: plot ggplot2 object (plot = TRUE). roles_definitions data frame describing seven role types conditions. result data frame node-level information: node name, module, z-score, participation coefficient, assigned role.","code":""},{"path":"/reference/calculate_roles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"community structure provided, modules automatically detected using specified clustering method. function can optionally produce 2D role plot (z vs. P) highlighting canonical role regions. node roles defined :","code":""},{"path":"/reference/calculate_roles.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"Guimerà, R., & Amaral, L. . N. (2005). Functional cartography complex metabolic networks. Nature, 433(7028), 895–900. doi:10.1038/nature03288","code":""},{"path":[]},{"path":"/reference/calculate_roles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Network Roles Based on Within-Module Z-Score and Participation Coefficient — calculate_roles","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::sample_gnp(200, 0.05, directed = F) igraph::V(g)$name <- as.character(1:200) result <- calculate_roles(g, plot = TRUE) head(result$result) } # }"},{"path":"/reference/compare_networks.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Two Networks — compare_networks","title":"Compare Two Networks — compare_networks","text":"function compares two networks using summary metrics, degree distributions, topological similarity measures. overlays complementary cumulative frequency distributions (CCDFs) degree returns combined report.","code":""},{"path":"/reference/compare_networks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Two Networks — compare_networks","text":"","code":"compare_networks(   graph1,   graph2,   remove_singles = FALSE,   show_PL = TRUE,   PL_exponents = c(2, 3),   colors = c(\"#e41a1c\", \"#000831\", \"#9c52f2\", \"#b8b8ff\"),   label.size = 12 )"},{"path":"/reference/compare_networks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Two Networks — compare_networks","text":"graph1 igraph object data.frame (edge list). graph2 igraph object data.frame (edge list). remove_singles Logical; remove single nodes analysis. show_PL Logical; whether fit display power law exponents. PL_exponents Vector; power-law slopes show. colors Optional vector colors CCDF plot. label.size Labels' size CCDF plot.","code":""},{"path":"/reference/compare_networks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Two Networks — compare_networks","text":"list : metrics1: Summary metrics graph1 metrics2: Summary metrics graph2 CCDF_plot: ggplot overlay ccdfs jaccard_similarity: Jaccard index edge sets node_overlap: Fraction shared nodes edge_overlap: Fraction shared edges ks_test: KS test result degree distributions","code":""},{"path":"/reference/compare_networks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Two Networks — compare_networks","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g1 <- sample_pa(100) g2 <- sample_gnp(100, 0.05, directed = F) compare_networks(g1, g2) } # }"},{"path":"/reference/compute_ccdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","title":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","text":"Computes CCDF node degrees given igraph object. CCDF useful visualizing degree distributions, particularly log-log plots, identify power-law heavy-tailed behaviors. Internal helper function plot_CCDF() compare_networks().","code":""},{"path":"/reference/compute_ccdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","text":"","code":"compute_ccdf(graph, mode = c(\"all\", \"in\", \"out\"), remove_singles = FALSE)"},{"path":"/reference/compute_ccdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","text":"graph igraph object representing graph. mode Character string indicating degree type compute. Options \"\" (default), \"\", \"\". relevant directed graphs. remove_singles Logical. TRUE, nodes degree zero removed computing degree distribution.","code":""},{"path":"/reference/compute_ccdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","text":"data frame two columns: degree Integer node degree values. ccdf Complementary cumulative distribution values (P(X ≥ x)).","code":""},{"path":"/reference/compute_ccdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the Complementary Cumulative Distribution Function (CCDF) of Node Degrees — compute_ccdf","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::sample_pa(1000, power = 2.5, directed = FALSE) ccdf_data <- compute_ccdf(g) plot(ccdf_data$degree, ccdf_data$ccdf, log = \"xy\", type = \"l\") } # }"},{"path":"/reference/find_bottlenecks.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","title":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","text":"Identifies bottleneck nodes igraph network low degree high betweenness centrality. function supports standardized (z-score) quantile-based thresholding. Optionally, produces 2D scatter plot bottlenecks highlighted.","code":""},{"path":"/reference/find_bottlenecks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","text":"","code":"find_bottlenecks(   graph,   method = c(\"zscore\", \"quantile\"),   degree_threshold = -1,   betweenness_threshold = 1,   degree_quantile = 0.25,   betweenness_quantile = 0.75,   log_transform = TRUE,   plot = TRUE,   focus_color = \"skyblue\",   bottleneck_names = TRUE,   bottleneck_cex = 3,   gg_extra = list() )"},{"path":"/reference/find_bottlenecks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. method Character. Method define bottlenecks: \"zscore\" \"quantile\". degree_threshold Numeric. Upper threshold standardized degree (used method = \"zscore\"). betweenness_threshold Numeric. Lower threshold standardized betweenness (used methods). degree_quantile Numeric 0 1. Quantile threshold degree (used method = \"quantile\"). betweenness_quantile Numeric 0 1. Quantile threshold betweenness (used method = \"quantile\"). log_transform Logical. TRUE, applies log1p transformation degree betweenness. plot Logical. TRUE, generates plot degree vs. betweenness highlighting bottlenecks. focus_color Character. Color display focus area plot (bottlenecks region). bottleneck_names Logical. TRUE, labels bottleneck nodes plot. bottleneck_cex Numeric. Font size scaling bottleneck labels plot. gg_extra List. Additional user-defined layers returned ggplot. eg. list(ylim(-2,2), theme_bw(), theme(legend.position = \"none\"))","code":""},{"path":"/reference/find_bottlenecks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","text":"list following components: method message describing method thresholds used. result tibble node name, degree, betweenness, transformed metrics, bottleneck status. graph original graph new vertex attribute bottleneck (logical). plot = TRUE, scatter plot degree vs. betweenness displayed, highlighting bottlenecks.","code":""},{"path":"/reference/find_bottlenecks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify and Bottleneck Nodes in a Network — find_bottlenecks","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g <- sample_pa(100) find_bottlenecks(g, method = \"quantile\", plot = TRUE) } # }"},{"path":"/reference/find_hubs.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify Hub Nodes in a Network — find_hubs","title":"Identify Hub Nodes in a Network — find_hubs","text":"function identifies hub nodes igraph network based degree betweenness centrality using either z-score quantile thresholds. Optionally, visualizes classification using scatter plot marginal histograms.","code":""},{"path":"/reference/find_hubs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify Hub Nodes in a Network — find_hubs","text":"","code":"find_hubs(   graph,   method = c(\"zscore\", \"quantile\"),   degree_threshold = 3,   betweenness_threshold = 1,   degree_quantile = 0.95,   betweenness_quantile = 0.95,   log_transform = TRUE,   plot = TRUE,   focus_color = \"darkgreen\",   label.size = 12,   hub_names = TRUE,   hub_cex = 3,   gg_extra = list() )"},{"path":"/reference/find_hubs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify Hub Nodes in a Network — find_hubs","text":"graph igraph object data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. method Character. Method identify hubs: \"zscore\" (standardized metrics) \"quantile\" (empirical percentiles). degree_threshold Numeric. Threshold standardized degree (used method = \"zscore\"). betweenness_threshold Numeric. Threshold standardized betweenness (used method = \"zscore\"). degree_quantile Numeric 0 1. Quantile threshold degree (used method = \"quantile\"). betweenness_quantile Numeric 0 1. Quantile threshold betweenness (used method = \"quantile\"). log_transform Logical. TRUE, applies log-transformation degree betweenness metrics. plot Logical. TRUE, generates plot degree vs. betweenness classification. focus_color Character. Color display focus area plot (hubs region). label.size Numeric. Base font size plot elements. Passed theme_classic. hub_names Logical. TRUE, adds node labels identified hubs plot. hub_cex Numeric. Font size scaling factor hub labels plot. gg_extra List. Additional user-defined layers returned ggplot. eg. list(ylim(-2,2), theme_bw(), theme(legend.position = \"none\"))","code":""},{"path":"/reference/find_hubs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify Hub Nodes in a Network — find_hubs","text":"list following components: method Description method thresholds used. result tibble node name, degree, betweenness, transformed metrics, hub status. graph original graph new vertex attribute is_hub. plot = TRUE, scatter plot degree vs. betweenness displayed hub nodes highlighted.","code":""},{"path":"/reference/find_hubs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify Hub Nodes in a Network — find_hubs","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g <- sample_pa(100) find_hubs(g, method = \"quantile\", plot = TRUE) } # }"},{"path":"/reference/find_modules.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect and Visualize Network Modules (Communities) — find_modules","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"Identifies modules (communities) network using variety community detection algorithms igraph package. Optionally filters small modules, visualizes detected modules, returns induced subgraphs module.","code":""},{"path":"/reference/find_modules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"","code":"find_modules(   graph,   method = \"louvain\",   min_size = 3,   no.of.communities = NULL,   return_subgraphs = FALSE,   plot = TRUE,   label = FALSE,   ... )"},{"path":"/reference/find_modules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. method Character. Community detection method. Options include: \"louvain\", \"walktrap\", \"infomap\", \"edge_betweenness\", \"fluid_communities\", \"fast_greedy\", \"leading_eigen\", \"leiden\", \"spinglass\". min_size Integer. Minimum number nodes required retain module. Modules smaller size discarded. Default 3. ..communities Integer. Required method = \"fluid_communities\". Specifies number communities find. return_subgraphs Logical. TRUE, returns list induced subgraphs detected module. plot Logical. TRUE, generates network plot colored module. label Logical. TRUE, displays node labels plot. ... Additional parameters passed plot_Net() function customizing plot.","code":""},{"path":"/reference/find_modules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"list following components: module_table tibble mapping node module assignment. n_modules number modules meet min_size threshold. subgraphs named list subgraphs module (return_subgraphs = TRUE). method community detection method used. graph input graph assigned 'module' 'color' vertex attributes, plot = TRUE. plot = TRUE, network plot displayed nodes colored module. #' @details function wrapper around several igraph community detection algorithms, including Louvain (cluster_louvain()), Walktrap, Infomap, Fast Greedy, others. simplifies application offers optional filtering, visualization via plot_Net(), module subgraph extraction.","code":""},{"path":"/reference/find_modules.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"Csardi G, Nepusz T. igraph software package complex network research. InterJournal, Complex Systems. 2006;1695. https://igraph.org","code":""},{"path":"/reference/find_modules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect and Visualize Network Modules (Communities) — find_modules","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g <- sample_pa(100) find_modules(g, method = \"louvain\", plot = TRUE) } # }"},{"path":"/reference/greedy_seed_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"function implements greedy algorithm select set k seed nodes candidate list resulting diffusion signal specified set target nodes maximized. supports multiple diffusion models (Laplacian, Heat Kernel, Random Walk Restart).","code":""},{"path":"/reference/greedy_seed_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"","code":"greedy_seed_selection(   graph,   target_nodes,   candidate_nodes = NULL,   method = c(\"laplacian\", \"heat\", \"rwr\"),   alpha = 0.7,   t = 1,   restart_prob = 0.3,   k = 5,   normalize = TRUE,   plot = TRUE )"},{"path":"/reference/greedy_seed_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. target_nodes character vector node names prioritize receiving diffusion signal. candidate_nodes Optional character vector eligible nodes consider seeds. NULL (default), non-target nodes used. method Diffusion method use. One \"laplacian\", \"heat\", \"rwr\". alpha Scaling parameter Laplacian diffusion method (default = 0.7). t Time parameter Heat Kernel diffusion (default = 1). restart_prob Restart probability Random Walk Restart (default = 0.3). k Number seed nodes select (default = 5). normalize Logical; whether normalize cumulative diffusion score target nodes (default = TRUE). plot Logical; whether plot progression target diffusion score seeds selected (default = TRUE).","code":""},{"path":"/reference/greedy_seed_selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"list following elements: selected Character vector selected seed node names. final_target_score Final cumulative (normalized) diffusion score target nodes. scores_at_each_step Vector target scores greedy selection step.","code":""},{"path":"/reference/greedy_seed_selection.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"function uses stepwise greedy heuristic. step, evaluates marginal gain target score adding candidate node current seed set, selects one highest gain. repeated k steps. Note: score candidate every step recomputed via full diffusion run, making function computationally intensive large graphs large k. target score can interpreted either total average diffusion signal received target nodes. Normalization helps scale results across networks different sizes.","code":""},{"path":[]},{"path":"/reference/greedy_seed_selection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Greedy Seed Node Selection to Maximize Diffusion Toward Target Nodes — greedy_seed_selection","text":"","code":"if (FALSE) { # \\dontrun{ g <- sample_gnp(50, 0.05, directed = F) target <- c(\"1\", \"2\", \"3\") greedy_seed_selection(g, target_nodes = target, k = 10) } # }"},{"path":"/reference/highlight_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Highlight Nodes in a Network Plot — highlight_nodes","title":"Highlight Nodes in a Network Plot — highlight_nodes","text":"Highlights selected nodes igraph object changing label, fill color, /outline color. function modifies node attributes visualizes result using plot_Net().","code":""},{"path":"/reference/highlight_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highlight Nodes in a Network Plot — highlight_nodes","text":"","code":"highlight_nodes(   graph,   nodes,   method = c(\"label\", \"fill\", \"outline\"),   label_color = \"darkred\",   highlight_fill_color = \"orange\",   highlight_frame_color = \"darkblue\",   background_color = \"gray\",   ... )"},{"path":"/reference/highlight_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highlight Nodes in a Network Plot — highlight_nodes","text":"graph igraph object data.frame representing symbolic edge list. data.frame, least two columns specifying source target nodes. nodes character vector node names highlight. method Character vector specifying highlight nodes. One : \"label\", \"fill\", \"outline\". label_color Color highlighted node labels. Used \"label\" method. Default \"darkred\". highlight_fill_color Fill color highlighted nodes. Used \"fill\" method. Default \"orange\". highlight_frame_color Outline color highlighted nodes. Used \"outline\" method. Default \"darkblue\". background_color Fill frame color non-highlighted nodes. Default \"gray\". ... Additional arguments passed plot_Net().","code":""},{"path":"/reference/highlight_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highlight Nodes in a Network Plot — highlight_nodes","text":"Invisibly returns igraph object updated attributes.","code":""},{"path":"/reference/highlight_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highlight Nodes in a Network Plot — highlight_nodes","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::make_ring(10) igraph::V(g)$name <- letters[1:10] highlight_nodes(g, nodes = c(\"a\", \"j\"), method = c(\"label\", \"fill\")) } # }"},{"path":"/reference/layout_horizontal_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","title":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","text":"Rotates tree layout -90 degrees produce horizontal orientation. particularly useful hierarchical visualizations left--right structure preferred default top--bottom tree layout.","code":""},{"path":"/reference/layout_horizontal_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","text":"","code":"layout_horizontal_tree(graph)"},{"path":"/reference/layout_horizontal_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","text":"graph igraph object representing input graph.","code":""},{"path":"/reference/layout_horizontal_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","text":"numeric matrix 2 columns representing x y coordinates node layout. matrix can passed plot.igraph() plotting functions.","code":""},{"path":"/reference/layout_horizontal_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Horizontal Tree Layout for Graph Visualization — layout_horizontal_tree","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::make_tree(10) coords <- layout_horizontal_tree(g) plot_Net(g, layout = coords) } # }"},{"path":"/reference/network_diffusion.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Network Diffusion from Seed Nodes — network_diffusion","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"Applies network diffusion techniques propagate influence set seed nodes across graph. Supports Laplacian smoothing, heat diffusion, random walk restart (RWR).","code":""},{"path":"/reference/network_diffusion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"","code":"network_diffusion(   graph,   seed_nodes,   method = c(\"laplacian\", \"heat\", \"rwr\"),   alpha = 0.7,   t = 1,   restart_prob = 0.3,   normalize = TRUE,   precompute = NULL )"},{"path":"/reference/network_diffusion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. Must named vertices. seed_nodes Character vector seed node names (must match V(graph)$name). method Character. Diffusion method use: \"laplacian\": Solves linear system \\((+ \\alpha L)^{-1} f_0\\), \\(L\\) (normalized) graph Laplacian \\(\\alpha\\) smoothing parameter. Internally, sparse Cholesky decomposition used efficiency. \"heat\": Applies heat diffusion model \\(e^{-tL} f_0\\), \\(t\\) controls diffusion time. truncated Taylor expansion used approximation. \"rwr\": Random Walk Restart. Iteratively solves \\(f = (1 - r)Pf + r f_0\\), \\(P\\) transition matrix \\(r\\) restart probability. alpha Damping factor Laplacian method. Default 0.7. t Time parameter heat diffusion method. Default 1. restart_prob Restart probability (usually 0.3 0.7) RWR method. Default 0.3. normalize Logical. Whether normalize adjacency matrix (symmetric normalization undirected graphs). Default TRUE. precompute Optional list precompute diffusion matrices (e.g., Laplacian, Cholesky factor, transition matrix). Use prepare_diffusion() generate object avoid redundant computations calling function repeatedly (e.g., greedy optimization).","code":""},{"path":"/reference/network_diffusion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"data frame two columns: node Node name score Diffusion score representing influence seed nodes","code":""},{"path":"/reference/network_diffusion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"function allows flexible application network diffusion strategies, useful systems biology (e.g., gene prioritization, pathway propagation), network analysis, disease gene discovery. underlying matrix operations based well-established diffusion models graph theory. \"rwr\" (random walk restart), algorithm iteratively propagates scores convergence based row-normalized transition matrix. Recommended method large networks. \"laplacian\" \"heat\", graph Laplacian computed (optionally normalized) adjacency matrix. efficiency iterative applications, precompute Laplacian Cholesky decomposition using prepare_diffusion().","code":""},{"path":"/reference/network_diffusion.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"Köhler S, Bauer S, Horn D, Robinson PN. Walking interactome prioritization candidate disease genes. J Hum Genet. 2008;82(4):949–958. doi:10.1016/j.ajhg.2008.02.013 Vanunu O, Magger O, Ruppin E, Shlomi T, Sharan R. Associating genes protein complexes disease via network propagation. PLoS Comput Biol. 2010;6(1):e1000641. doi:10.1371/journal.pcbi.1000641","code":""},{"path":"/reference/network_diffusion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Network Diffusion from Seed Nodes — network_diffusion","text":"","code":"if (FALSE) { # \\dontrun{ g <- sample_gnp(100, 0.05, directed = F) V(g)$name <- as.character(seq_len(vcount(g))) seed_nodes <- sample(V(g)$name, 5) network_diffusion(g, seed_npodes, method = \"laplacian\") } # }"},{"path":"/reference/network_diffusion_with_pvalues.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"Applies network diffusion techniques propagate influence set seed nodes across graph. Supports Laplacian smoothing, heat diffusion, random walk restart (RWR).","code":""},{"path":"/reference/network_diffusion_with_pvalues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"","code":"network_diffusion_with_pvalues(   graph,   seed_nodes,   method = c(\"laplacian\", \"heat\", \"rwr\"),   alpha = 0.7,   t = 1,   restart_prob = 0.3,   normalize = TRUE,   n_permutations = 1000,   seed = NULL,   verbose = TRUE )"},{"path":"/reference/network_diffusion_with_pvalues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. Must named vertices. seed_nodes Character vector seed node names (must match V(graph)$name). method Character. Diffusion method use: \"laplacian\": Solves linear system \\((+ \\alpha L)^{-1} f_0\\), \\(L\\) (normalized) graph Laplacian \\(\\alpha\\) smoothing parameter. Internally, sparse Cholesky decomposition used efficiency. \"heat\": Applies heat diffusion model \\(e^{-tL} f_0\\), \\(t\\) controls diffusion time. available, sparse approximation method used avoid dense matrix exponential. \"rwr\": Random Walk Restart. Iteratively solves \\(f = (1 - r)Pf + r f_0\\), \\(P\\) transition matrix \\(r\\) restart probability. alpha Damping factor Laplacian method. Default 0.7. t Time parameter heat diffusion method. Default 1. restart_prob Restart probability (usually 0.3 0.7) RWR method. Default 0.3. normalize Logical. Whether normalize adjacency matrix (symmetric normalization undirected graphs). Default TRUE. n_permutations Integer. Number permutations run empirical p-value estimation (default 1000). seed Optional integer reproducible random number generation. NULL (default), seed set. verbose Logical. TRUE (default), displays progress bar permutations.","code":""},{"path":"/reference/network_diffusion_with_pvalues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"data frame two columns: node Node name score Diffusion score representing influence seed nodes","code":""},{"path":"/reference/network_diffusion_with_pvalues.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"function allows flexible application network diffusion strategies, useful systems biology (e.g., gene prioritization, pathway propagation), network analysis, disease gene discovery. underlying matrix operations based well-established diffusion models graph theory. \"rwr\" (random walk restart), algorithm iteratively propagates scores convergence based row-normalized transition matrix. Recommended method large networks. \"laplacian\" \"heat\", graph Laplacian computed (optionally normalized) adjacency matrix.","code":""},{"path":"/reference/network_diffusion_with_pvalues.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"Köhler S, Bauer S, Horn D, Robinson PN. Walking interactome prioritization candidate disease genes. J Hum Genet. 2008;82(4):949–958. doi:10.1016/j.ajhg.2008.02.013 Vanunu O, Magger O, Ruppin E, Shlomi T, Sharan R. Associating genes protein complexes disease via network propagation. PLoS Comput Biol. 2010;6(1):e1000641. doi:10.1371/journal.pcbi.1000641","code":""},{"path":"/reference/network_diffusion_with_pvalues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Network Diffusion from Seed Nodes — network_diffusion_with_pvalues","text":"","code":"if (FALSE) { # \\dontrun{ g <- sample_gnp(100, 0.05, directed = F) V(g)$name <- as.character(seq_len(vcount(g))) seed_nodes <- sample(V(g)$name, 5) network_diffusion_with_pvalues(g, seed_npodes, method = \"laplacian\") } # }"},{"path":"/reference/plot_CCDF.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","title":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","text":"function plots complementary cumulative distribution function (CCDF) node degrees network optionally overlays power-law reference curves.","code":""},{"path":"/reference/plot_CCDF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","text":"","code":"plot_CCDF(   graph,   keep_direction = TRUE,   remove_singles = FALSE,   show_PL = TRUE,   PL_exponents = c(2, 3),   colors = c(\"#000831\", \"#e41a1c\", \"darkgreen\", \"#9c52f2\", \"#b8b8ff\"),   label.size = 12 )"},{"path":"/reference/plot_CCDF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","text":"graph igraph object representing network analyze data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. keep_direction Logical. directed graphs. TRUE, CCDF curves drawn ''-dgree, ''-degree, ''-degree distributions. FALSE ignore directionality. remove_singles Logical. TRUE, nodes degree 0 removed graph computing CCDF. Default FALSE. show_PL Logical. TRUE, overlays theoretical power-law reference lines form \\(P(K > k) \\sim k^{-\\gamma}\\). Default TRUE. PL_exponents Numeric vector. \\(\\gamma\\) exponents power-law curves. Default c(2, 3). colors Optional character vector. Custom colors graph curve power-law lines. NULL, default colors used. label.size Numeric. Font size axis labels theme. Passed theme_minimal.","code":""},{"path":"/reference/plot_CCDF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","text":"ggplot2 object showing CCDF node degrees log-log scale.","code":""},{"path":"/reference/plot_CCDF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Complementary Cumulative Degree Distribution (CCDF) — plot_CCDF","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g <- sample_pa(1000) plot_CCDF(g, remove_singles = TRUE) } # }"},{"path":"/reference/plot_Net.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","title":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","text":"function plots igraph network graph options customize node size based vertex degree numeric vertex attribute, set node edge colors, label nodes, adjust edge widths (optionally mapped edge betweenness centrality).","code":""},{"path":"/reference/plot_Net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","text":"","code":"plot_Net(   graph,   label = FALSE,   color = \"#006d77\",   color_ramp = c(\"blue\", \"white\", \"red\"),   NA_color = \"gray\",   frame.color = NULL,   node.size.factor = 1,   node.degree.map = TRUE,   edge.color = \"#999999\",   edge.width.factor = 1,   edge.bw.map = TRUE,   label.color = \"#e29578\",   label.size = 1,   layout = NULL,   ... )"},{"path":"/reference/plot_Net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","text":"graph igraph object representing network plot data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. label Logical, character vector. FALSE, node labels shown. TRUE, node labels set vertex names existing labels. character vector length equal number vertices, used custom node labels. color Character. Color node fill, existing vertex attribute name map node fill color. Default '#006d77'. color_ramp character vector colors (e.g., c(\"blue\", \"white\", \"red\")) used create continuous color ramp mapping numeric node attributes colors. Ignored fixed color provided node color categorical. Passed colorRampPalette interpolate gradient colors. NA_color Node color NAs node color mapping. frame.color Character. Color node frame, existing vertex attribute name map node frame color. Default NULL. node.size.factor Numeric character. numeric, acts constant scaling factor node size. character, name numeric vertex attribute used size nodes. node.degree.map Logical. TRUE node.size.factor numeric, node size mapped vertex degree multiplied node.size.factor. Ignored node.size.factor character. edge.color Character. Color edges. Default '#999999'. edge.width.factor Numeric. Factor scale edge widths. Default 1. edge.bw.map Logical. TRUE, edge widths mapped log-transformed edge betweenness centrality. Otherwise, edges uniform width. label.color Character. Color node labels. Default '#e29578'. label.size Numeric. Character expansion factor label size. Default 1. layout Optional numeric matrix specifying vertex coordinates layout. ... Additional parameters passed plot.igraph.","code":""},{"path":"/reference/plot_Net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","text":"Invisibly returns NULL. function produces plot.","code":""},{"path":"/reference/plot_Net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an igraph network with customizable node sizes and edge widths — plot_Net","text":"","code":"if (FALSE) { # \\dontrun{ library(igraph) g <- random.graph.game(100, 0.02) plot_Net(g, label = TRUE, node.size.factor = 2) } # }"},{"path":"/reference/prepare_diffusion.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Diffusion Matrix — prepare_diffusion","title":"Prepare Diffusion Matrix — prepare_diffusion","text":"Prepares normalizes diffusion kernel matrix used network diffusion.","code":""},{"path":"/reference/prepare_diffusion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Diffusion Matrix — prepare_diffusion","text":"","code":"prepare_diffusion(   graph,   method = c(\"laplacian\", \"heat\", \"rwr\"),   alpha = 0.7,   t = 1,   restart_prob = 0.3,   normalize = TRUE )"},{"path":"/reference/prepare_diffusion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Diffusion Matrix — prepare_diffusion","text":"graph igraph object data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. method Character string: one \"laplacian\", \"heat\", \"rwr\". alpha Numeric (used \"laplacian\"). t Time parameter (used \"heat\"). restart_prob Restart probability (used \"rwr\").","code":""},{"path":"/reference/prepare_diffusion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Diffusion Matrix — prepare_diffusion","text":"matrix representing diffusion kernel.","code":""},{"path":"/reference/robustness_analysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"Simulates removal nodes network using various strategies evaluates structure degrades using selected robustness metrics. Useful assessing vulnerability resilience graph.","code":""},{"path":"/reference/robustness_analysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"","code":"robustness_analysis(   graph,   removal_strategy = c(\"random\", \"degree\", \"betweenness\"),   steps = 50,   metrics = c(\"lcc_size\", \"efficiency\", \"n_components\"),   n_reps = 50,   plot = TRUE,   seed = NULL )"},{"path":"/reference/robustness_analysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"graph igraph object representing network plot data frame containing symbolic edge list first two columns. Additional columns considered edge attributes. Must undirected; directed graphs converted. removal_strategy Character. Strategy used node removal. Options : \"random\", \"degree\", \"betweenness\", name numeric vertex attribute. Custom attributes interpreted priority scores (higher = removed first). steps Integer. Number removal steps (default: 50). metrics Character vector. Structural metrics compute step. Options include: \"lcc_size\", \"efficiency\", \"n_components\". n_reps Integer. Number simulation repetitions (relevant removal_strategy = \"random\"). plot Logical. TRUE, robustness plot generated. seed Integer NULL. Random seed reproducibility.","code":""},{"path":"/reference/robustness_analysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"list : all_results data frame simulation results across steps repetitions. summary summarized data frame (mean SD) n_reps > 1, otherwise raw results. auc Named list AUC (area curve) values selected metric. plot = TRUE, ggplot object generated showing evolution selected metrics nodes progressively removed.","code":""},{"path":"/reference/robustness_analysis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"function builds classic approaches network science evaluating structural robustness (e.g., Albert, Jeong, & Barabási, Nature 2000) simulating progressive node removal quantifying degradation key topological features. deterministic strategies (\"degree\", \"betweenness\", custom attributes), nodes removed fixed priority order. \"random\" strategy, process repeated n_reps times, results aggregated. #' @references Albert R, Jeong H, Barabási AL. Error attack tolerance complex networks. Nature. 2000;406(6794):378–382. doi:10.1038/35019019 function uses: Largest Connected Component (LCC): Size largest remaining component. Global Efficiency: Average inverse shortest path length among pairs. Number Components: Total number disconnected components. Additionally, Area Curve (AUC) calculated metric, providing scalar summary robustness. higher AUC indicates greater resilience (.e., slower degradation). implementation inspired principles described : Albert R, Jeong H, Barabási AL. Error attack tolerance complex networks. Nature. 2000;406:378–382. (doi:10.1038/35019019 ) function uses: Size largest connected component (lcc_size) Global efficiency (average inverse shortest path length) Number components (n_components) evaluate robust network remains progressive node failure.","code":""},{"path":"/reference/robustness_analysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Network Robustness Analysis via Node Removal Simulation — robustness_analysis","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::sample_pa(100) robustness_analysis(g, removal_strategy = \"degree\", metrics = c(\"lcc_size\", \"n_components\")) } # }"},{"path":"/reference/summarize_graph_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Topological Properties of a Graph — summarize_graph_metrics","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"Computes comprehensive set global topological metrics input graph, including basic structure, connectivity, spectral properties, complexity. Supports igraph objects data frames representing edge lists.","code":""},{"path":"/reference/summarize_graph_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"","code":"summarize_graph_metrics(graph)"},{"path":"/reference/summarize_graph_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"graph igraph object data frame columns representing edge list.","code":""},{"path":"/reference/summarize_graph_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"tibble one row multiple columns, representing graph-level metric.","code":""},{"path":"/reference/summarize_graph_metrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"Metrics computed: Number nodes edges Directed TRUE/FALSE Graph density Diameter average path length largest connected component Clustering coefficient (transitivity) Degree assortativity Average degree betweenness centrality Number connected components size largest connected component Number single nodes Algebraic connectivity (second-smallest Laplacian eigenvalue) Degree entropy (Shannon entropy degree distribution) Gini coefficient node degrees Modularity community structure (via Louvain algorithm)","code":""},{"path":"/reference/summarize_graph_metrics.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"Newman, M. E. J. (2010). Networks: Introduction. Oxford University Press. Estrada, E. (2012). Structure Complex Networks: Theory Applications. Oxford University Press. Latora, V., Nicosia, V., & Russo, G. (2017). Complex Networks: Principles, Methods Applications. Cambridge University Press. Louvain modularity method: Blondel, V. D., Guillaume, J. L., Lambiotte, R., & Lefebvre, E. (2008). Fast unfolding communities large networks. J. Stat. Mech., 2008(10), P10008.","code":""},{"path":"/reference/summarize_graph_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Topological Properties of a Graph — summarize_graph_metrics","text":"","code":"if (FALSE) { # \\dontrun{ g <- igraph::sample_gnp(200, 0.05, directed = F) summarize_graph_metrics(g) } # }"}]
